ptPerMm = (72 / 25.4);ptPerIn = 72;setup();create(6*ptPerMm,6*ptPerMm, 3*ptPerMm, .1*ptPerMm, true, false);function create(toothwidth, gapwidth, toothheight, kerf,inverse, pathsAnticlockwise) {    if ( app.documents.length > 0 ) {        if (!checkParams(toothwidth, gapwidth, toothheight, kerf)) {            alert("All heights and lengths must be greater than 0");            return;        }                var selected = app.activeDocument.selection;        var direction = [selected.length];        for (i=0; i< selected.length; i++) {            var wasClosed = selected[i].closed;            selected[i].closed = true;            direction[i] = selected[i].area > 0;            selected[i].closed = wasClosed;        }        var selectedInfo = checkSelected(selected, direction);        if (selectedInfo.length == selected.length) {            for (i = 0;i < selected.length ; i++) {                addFingerJointsToLine(selected[i], selectedInfo[i], toothwidth, gapwidth, toothheight, kerf, i % 2 != inverse ? 1 : 0, direction[i] );            }        }    }}function checkParams(toothwidth, gapwidth, toothheight, kerf) {    for(var i=0;i<arguments.length;i++) {        if (arguments[i] <= 0) {            return false;        }    }    return true;}function checkSelected(selected, direction) {    var pathInfo = [];    if (selected.length > 0) {        if (selected.length > 2) {            alert("Please select no more than two segments.");            return pathInfo;        }        var lastLength = 0;        for (i = 0;i < selected.length ; i++) {            if (selected[i].selectedPathPoints.length != 2) {                alert("Please select segments between two anchors. Make sure only one segment per path is selected.");                return pathInfo;            }            selectionInfo = calculatePathInfo(selected[i], direction[i]);            if (selectionInfo == false) {                alert("Please select segments between two anchors");                return pathInfo;            }            var roundedLength =round(selectionInfo.length, 1);            if (lastLength != 0 && lastLength != roundedLength) {                alert("Please select segments with the same length\n" + lastLength + "\n" + roundedLength);                return pathInfo;            }            lastLength = round(selectionInfo.length,1);            pathInfo.push(selectionInfo);        }    }    return pathInfo;}function calculatePathInfo(selection, clockwise) {    var pathPoints= selection.selectedPathPoints;        // Determine the 'left' and 'right' points    var leftPoint;    var rightPoint;    for (var i=0; i<pathPoints.length;i++){        if (pathPoints[i].selected == PathPointSelection.LEFTRIGHTPOINT) {            return false;        }        if (pathPoints[i].selected == PathPointSelection.LEFTDIRECTION) {            rightPoint = pathPoints[i];        }        if(pathPoints[i].selected == PathPointSelection.RIGHTDIRECTION) {            leftPoint = pathPoints[i];        }    }    if (leftPoint == null || rightPoint == null) {        return false;    }    var p2p = bearingToAnchor(rightPoint.anchor, leftPoint.anchor);    return {         leftPoint : leftPoint,        rightPoint : rightPoint,        angle : p2p.angle,        length : p2p.length    };}function bearingToAnchor(a, b) {    var dX = a[0] - b[0];    var dY = a[1] - b[1];        var length = Math.sqrt(dX*dX + dY*dY);    var angle = Math.atan2(dY, dX);//~     alert( "\nWidth: " + dX +"\nHeight: " + dY + "\nLength: " +length //~         + "\nAngle: " + angle*180/Math.PI  );    return { length: length, angle: angle};}function removeAnchors(selection) {    if (selection.length == 0) {        return;    }    var pathPoints= selection[0].selectedPathPoints;    for (i=0; i<pathPoints.length;i++){        if (pathPoints[i].selected == PathPointSelection.ANCHORPOINT) {            pathPoints[i].remove();        }    }}function calculateOffsetsForTeeth(teeth, pathInfo, toothWidth, gapwidth, toothHeight, kerf, inverse, clockwise) {    var totalToothWidth = (teeth)*(toothWidth+gapwidth)-gapwidth;    var startHeight = toothHeight + kerf;    startHeight = clockwise ? startHeight : -1*startHeight;    var offset = (pathInfo.length - totalToothWidth) / 2;    var inverseOffset = 0;    if (inverse) {        var tan = round(Math.tan(pathInfo.angle),0);        if (tan) {            inverseOffset= (startHeight) / tan;        }        offset += inverseOffset;    }    return { offset: offset, inverseOffset: inverseOffset, startHeight: startHeight};}function getTeethForLength(pathLength, toothHeight, toothWidth, gapwidth) {    // minus height*2 to allow material thickness to be spared from teeth    return teeth = Math.floor((pathLength-toothHeight*2)/ (toothWidth+gapwidth));}// adds squared finger joints to the selected line segmentfunction addFingerJointsToLine(selection, pathInfo, toothWidth, gapwidth, toothHeight, kerf, inverse, clockwise) {        var teeth = getTeethForLength(pathInfo.length, toothHeight, toothWidth, gapwidth);    if (teeth < 1) {        return;    }    var offsets = calculateOffsetsForTeeth(teeth, pathInfo, toothWidth, gapwidth, toothHeight, kerf, inverse, clockwise);    var allPoints = selection.pathPoints;    var newPathPoints = [];    for (var i=0;i<allPoints.length;i++) {        var point = allPoints[i];        if (inverse && (anchorsEqual(allPoints[i].anchor, pathInfo.leftPoint.anchor) || anchorsEqual(allPoints[i].anchor, pathInfo.rightPoint.anchor))) {            newPathPoints.push(calculatePoint(point, pathInfo.angle, offsets.inverseOffset, offsets.startHeight));        }        else {            newPathPoints.push(point.anchor);        }        if (anchorsEqual(point.anchor, pathInfo.leftPoint.anchor)) {            // add all of the intermediate points            for (j=0; j<teeth; j++) {                drawTooth(newPathPoints, inverse, clockwise, pathInfo.leftPoint, pathInfo.angle, offsets.offset, j, toothWidth, gapwidth, toothHeight, kerf);            }        }    }    selection.setEntirePath(newPathPoints);}function drawTooth(pathPoints, inverse, clockwise, lineStart, lineAngle, offset, index, width, gapwidth, height, kerf) {    var toothStart = offset + index*(width+gapwidth);    var toothEnd = toothStart+width;    if (inverse) {        toothStart -= kerf/2;        toothEnd += kerf/2;    }    else {        toothStart += kerf/2;        toothEnd -= kerf/2;    }        var toothHeight = inverse ? height+kerf : 0;    var gapHeight = inverse ? 0 : height+kerf;    if ( !clockwise) {        toothHeight = 0-toothHeight;        gapHeight = 0 - gapHeight;    }    pathPoints.push(calculatePoint(lineStart, lineAngle, toothStart, toothHeight));    pathPoints.push(calculatePoint(lineStart, lineAngle, toothStart, gapHeight));    pathPoints.push(calculatePoint(lineStart, lineAngle, toothEnd, gapHeight));    pathPoints.push(calculatePoint(lineStart, lineAngle, toothEnd, toothHeight));}function calculatePoint(origin, angle, along, notch) {    var arr = [];    arr.push(origin.anchor[0]+Math.cos(angle)*along + Math.sin(angle)*notch);    arr.push(origin.anchor[1]+Math.sin(angle)*along - Math.cos(angle)*notch);    return arr;}function setup() {    Array.prototype.containsAnchor = function(anchor) {        var i = this.length;        while (i--) {            if (anchorsEqual(this[i], anchor)) {                return true;            }        }        return false;    }}function anchorsEqual(a, b) {    if (a[0] == b[0] && a[1] == b[1]) {        return true;    }    return false;}function round(value, precision) {    return Number(Math.round(value+'e'+precision)+'e-'+precision);}