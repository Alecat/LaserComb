ptPerMm = (72 / 25.4);function setup() {    Array.prototype.contains = function(obj) {        var i = this.length;        while (i--) {            if (this[i].typename == "PathPoint") {                if(anchorsEqual(this[i].anchor, obj.anchor)) {                    return i;                }            }            if (this[i] == obj) {                return i;            }        }        return false;    }    Array.prototype.containsNumWithMargin = function(obj, precision) {        var i = this.length;        while (i--) {            if (compareNumWithMargin(this[i],obj, precision)) {                return i;            }        }        return false;    }}function compareNumWithMargin(a,b,precision) {    var rounda = round(a, precision);    var roundb = round(b, precision);    if (rounda == roundb) {        return true;    }    // allow for decimal diffs    var margin = '1e-'+precision;    if (Math.abs(rounda) + margin >= Math.abs(roundb) && Math.abs(rounda) - margin <= Math.abs(roundb)) {        return true;    }    return false;}function pathPointsEqual(a, b) {    return anchorsEqual(a.anchor, b.anchor);}function anchorsEqual(a, b) {    if (a[0] == b[0] && a[1] == b[1]) {        return true;    }    return false;}function round(value, precision) {    return Number(Math.round(value+'e'+precision)+'e-'+precision);}setup();var angle = onEdge(app.activeDocument.selection);//alert("angle: " + (angle * 180 / Math.PI) + "°");function removeAnchors(selection) {    if (selection.length == 0) {        return;    }    var point = selection[0].selectedPathPoints[0];    var pathItem= selection[0];    var bounds = pathItem.geometricBounds;    pathItem.setEntirePath([        [ bounds[0], bounds[1] ],        [ bounds[2], bounds[1] ],        [ bounds[2], bounds[3] ],        [ bounds[0], bounds[3] ],        ]    );    }function onEdge() {    //Find the angle between every point from the start point.    //The first instance of a repeated angle should represent the angle along with which the edge is aligned    if (selection.length == 0) {        return;    }    var pathItem = selection[0];    var pathPoints= pathItem.selectedPathPoints;    var allPP = pathItem.pathPoints;    if (allPP.length < 2) {        return;    }    var startPoint = getFirstSelectedPoint(pathPoints);    //var ellipse = app.activeDocument.layers[0].pathItems.star(startPoint.anchor[0], startPoint.anchor[1], 5, 2, 5 );    var allPoints = [];    for (var i=0;i<allPP.length;i++){        allPoints.push(allPP[i]);    }    var startIndex = allPoints.contains(startPoint);    var backwardsAngle = false;    var angle = searchForAngle(startIndex, allPoints, true, pathItem);    if (angle.angle === null) {        backwardsAngle = true;        angle = searchForAngle(startIndex, allPoints, false, pathItem);    }    if (angle.angle === null) {        return;    }    // search again to find all points, forwards and backwards, that match the angle we found.    var linePoints = [];    if (startIndex > 0 && startIndex < allPoints.length-1) {        linePoints.push(startPoint);    }    var replacements = {};    // search forwards    var dirs = [true, false];    for (var k=0;k<2;k++) {        forwards = dirs[k];        var lookBack = (forwards && !backwardsAngle) || (!forwards && backwardsAngle) ;        var lastPoint = startPoint;        var i = startIndex;        var j = 0;        i = nextPointIndex(i, forwards, allPoints, pathItem.closed);        while(i != startIndex && i !== null) {            var pointToPrevious;            pointToPrevious = forwards ? bearingToAnchor(allPoints[i].anchor, lastPoint.anchor) : bearingToAnchor(lastPoint.anchor, allPoints[i].anchor);                        var compIndex = lookBack ? j % 4 : 3 - (j %4);            // Are the angles following the correct sequence?            if(compareNumWithMargin(pointToPrevious.angle, angle.anglesDiff[compIndex],6)) {                // Are the lengths following the correct sequence?                if ( pointToPrevious.length == angle.lengthsDiff[compIndex]) {                    forwards ? linePoints.push(allPoints[i]) : linePoints.unshift(allPoints[i]);                }                else {                    var pointToStart = forwards ? bearingToAnchor(allPoints[i].anchor, startPoint.anchor) : bearingToAnchor(startPoint.anchor, allPoints[i].anchor);                    var startToPoint = !forwards ? bearingToAnchor(allPoints[i].anchor, startPoint.anchor) : bearingToAnchor(startPoint.anchor, allPoints[i].anchor);                    var nextIndex = nextPointIndex(i, forwards, allPoints, pathItem.closed);                    if (nextIndex !== null) {                        // take into account angle to point after this one.                        var nextPoint = allPoints[nextIndex];                        var pointToNext = !forwards ? bearingToAnchor(nextPoint.anchor, allPoints[i].anchor) : bearingToAnchor(allPoints[i].anchor, nextPoint.anchor);                                                if (!compareNumWithMargin(pointToStart.angle, angle.angle, 6)) {                            var A1 = Math.sin(angle.angle);                            var A2 = Math.sin(pointToNext.angle);                            var B1 = -1*Math.cos(angle.angle);                            var B2 = -1*Math.cos(pointToNext.angle);                            var delta = A1*B2 - A2*B1;                                                        var C1 = Math.sin(angle.angle) * startPoint.anchor[0] - Math.cos(angle.angle) * startPoint.anchor[1];                            var C2 = Math.sin(pointToNext.angle) * nextPoint.anchor[0] - Math.cos(pointToNext.angle) * nextPoint.anchor[1];                            if(delta != 0) {                                var newx = (B2*C1 - B1*C2)/delta;                                var newy = (A1*C2 - A2*C1)/delta;                                replacements[i] = [newx, newy];                            }                        }                    }                    else if (!compareNumWithMargin(pointToStart.angle, angle.angle, 6)) {                        var newx = allPoints[i].anchor[0] + Math.cos(angle.toothAngle)*angle.toothHeight;                        var newy = allPoints[i].anchor[1] + Math.sin(angle.toothAngle)*angle.toothHeight;                        replacements[i] = [newx, newy];                    }                    break;                }            }            else {                break;            }            lastPoint = allPoints[i];            i = nextPointIndex(i, forwards, allPoints, pathItem.closed);            j++;        }    }    var newPathPoints = [];    for (var i=0;i<allPoints.length;i++) {        if (i in replacements) {            newPathPoints.push(replacements[i]);        }        else if (linePoints.contains(allPoints[i]) === false) {            newPathPoints.push(allPoints[i].anchor);        }    }        pathItem.setEntirePath(newPathPoints);    return angle.angle;}function getFirstSelectedPoint(pathPoints) {    for(var i=0;i<pathPoints.length;i++) {        if (pathPoints[i].selected == PathPointSelection.ANCHORPOINT) {            return pathPoints[i];        }    }    return null;}function searchForAngle(startIndex, allPoints, searchForwards, pathItem) {    var startPoint = allPoints[startIndex];    var angles = [];    var lengthsDiff = [];    var anglesDiff = [];    var i = startIndex;    i = nextPointIndex(i, searchForwards, allPoints, pathItem.closed);    var lastPoint = startPoint;    var angle = null;    var toothHeight = null;    var toothAngle = null;    while(angles.length < 4 && angle === null && i !== null) {        var pointToStart = searchForwards ? bearingToAnchor(allPoints[i].anchor, startPoint.anchor) : bearingToAnchor(startPoint.anchor, allPoints[i].anchor);        var pointToPrevious = searchForwards ? bearingToAnchor(allPoints[i].anchor, lastPoint.anchor) : bearingToAnchor(lastPoint.anchor, allPoints[i].anchor);        if (angle === null && angles.containsNumWithMargin(pointToStart.angle, 6) !== false) {            angle = pointToStart.angle;        }        // Within four points: If a length is repeated then it is the height of the tooth. However it can't be the immediately prior point.        if (lengthsDiff.length >= 2 && toothHeight === null) {            var lengthIndex = lengthsDiff.slice(0, lengthsDiff.length - 1).contains(pointToPrevious.length);            if (lengthIndex !== false) {                toothHeight = pointToPrevious.length;                toothAngle = pointToPrevious.angle;            }        }        angles.push(pointToStart.angle);        lengthsDiff.push(pointToPrevious.length);        anglesDiff.push(pointToPrevious.angle);        var lastPoint = allPoints[i];        i = nextPointIndex(i, searchForwards, allPoints, pathItem.closed);    } // we should find the angle within four points     if (!searchForwards) {        toothAngle += Math.PI;    }    // Now look to see if the next point is along the path - if not, forget it, we're at an edge    if (i != null) {        var pointToPrevious = searchForwards ? bearingToAnchor(allPoints[i].anchor, lastPoint.anchor) : bearingToAnchor(lastPoint.anchor, allPoints[i].anchor);        // angle should be the same as the first angle was to the startPoint        if (!compareNumWithMargin(angles[0], pointToPrevious.angle, 6) || !compareNumWithMargin(lengthsDiff[0], pointToPrevious.length, 6)) {            return { angle: null, toothHeight: null, toothAngle: null, lengthsDiff: [], anglesDiff: []};        }    }    return { angle : angle, toothHeight: toothHeight, toothAngle: toothAngle, lengthsDiff: lengthsDiff, anglesDiff: anglesDiff};}function bearingToAnchor(a, b) {    //draw indicitive circle around point being examined    //var ellipse = app.activeDocument.layers[0].pathItems.polygon(a[0], a[1], 5, 5, false, false );    var dX = a[0] - b[0];    var dY = a[1] - b[1];        var length = round(Math.sqrt(dX*dX + dY*dY),5);    var angle = Math.atan2(dY, dX);    return { fromPoint:a, toPoint:b, length: length, angle: angle};}// When iterating through a series of points, we may need to loop back to the first point in the series// TODO don't loop for closed pathsfunction nextPointIndex(i, forwards, allPoints, closed) {    var index = forwards ? i+1 : i-1;    if (index < 0) {        if (!closed) {            return null;        }        index = allPoints.length - 1;    }    if (index >= allPoints.length) {        if (!closed) {            return null;        }        index = 0;    }    return index;}